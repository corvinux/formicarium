use anyhow::Result;
use ggez::graphics;
use semeion::*;
use std::cell::Cell;
use std::collections::HashMap;

use super::conf::Conf;
use crate::entity::{ant, grid, morsel, nest, phero, Kind};

/// The game context.
#[derive(Default)]
pub struct Context {
    // The environment contextual information
    pub conf: Conf,
    // The next available entity ID.
    id: Cell<entity::Id>,
    // The map of entities meshes depending on their kind.
    meshes: HashMap<Kind, graphics::Mesh>,
}

impl Context {
    /// Constructs a new game context with no graphics context.
    pub fn new(conf: Conf) -> Self {
        Self {
            conf,
            id: Cell::default(),
            meshes: HashMap::default(),
        }
    }

    /// Constructs a new game context with meshes for each entity kind.
    pub fn with_context(conf: Conf, ctx: &mut ggez::Context) -> Result<Self> {
        let mut context = Self::new(conf);
        let conf = &context.conf;

        // initialize the meshes map for each entity kind
        context.meshes.insert(Kind::Grid, grid::mesh(ctx, conf)?);
        context.meshes.insert(Kind::Nest, nest::mesh(ctx, conf)?);
        context
            .meshes
            .insert(Kind::Morsel, morsel::mesh(ctx, conf)?);
        context.meshes.insert(Kind::Ant, ant::mesh(ctx, conf)?);

        let scents = [phero::Scent::Colony, phero::Scent::Food];
        for &scent in &scents {
            context
                .meshes
                .insert(Kind::Phero { scent }, phero::mesh(scent, ctx, conf)?);
        }

        Ok(context)
    }

    /// Gets a new Entity unique ID.
    ///
    /// IDs are simply generated by picking the next value, this gives us
    /// around 300 million years before we run out of ID if we keep generating a
    /// new ID every millisecond on a 64 bit target.
    pub fn unique_id(&self) -> entity::Id {
        let next = self.id.get();
        self.id.set(next.wrapping_add(1));
        next
    }

    /// Gets the graphics mesh associated with the given entity kind.
    pub fn kind_mesh(&self, kind: &Kind) -> &graphics::Mesh {
        self.meshes
            .get(kind)
            .unwrap_or_else(|| panic!("Mesh not found for {:?}", kind))
    }
}
